// Generated by gencpp from file nlosExclusion/GNSS_Raw_mf.msg
// DO NOT EDIT!


#ifndef NLOSEXCLUSION_MESSAGE_GNSS_RAW_MF_H
#define NLOSEXCLUSION_MESSAGE_GNSS_RAW_MF_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace nlosExclusion
{
template <class ContainerAllocator>
struct GNSS_Raw_mf_
{
  typedef GNSS_Raw_mf_<ContainerAllocator> Type;

  GNSS_Raw_mf_()
    : GNSS_week(0.0)
    , GNSS_time(0.0)
    , total_sv(0.0)
    , prn_satellites_index(0.0)
    , constellation(0.0)
    , pseudorange()
    , raw_pseudorange()
    , carrier_phase()
    , raw_carrier_phase()
    , doppler()
    , lamda()
    , snr()
    , GNCWeights(0.0)
    , LLI(0)
    , slip(0)
    , elevation(0.0)
    , azimuth(0.0)
    , err_tropo(0.0)
    , err_iono()
    , sat_clk_err(0.0)
    , sat_pos_x(0.0)
    , sat_pos_y(0.0)
    , sat_pos_z(0.0)
    , ttx(0.0)
    , vel_x(0.0)
    , vel_y(0.0)
    , vel_z(0.0)
    , dt(0.0)
    , ddt(0.0)
    , tgd(0.0)
    , visable(0)
    , sat_system()
    , visable3DMA(0)
    , prE3dMA(0.0)  {
    }
  GNSS_Raw_mf_(const ContainerAllocator& _alloc)
    : GNSS_week(0.0)
    , GNSS_time(0.0)
    , total_sv(0.0)
    , prn_satellites_index(0.0)
    , constellation(0.0)
    , pseudorange(_alloc)
    , raw_pseudorange(_alloc)
    , carrier_phase(_alloc)
    , raw_carrier_phase(_alloc)
    , doppler(_alloc)
    , lamda(_alloc)
    , snr(_alloc)
    , GNCWeights(0.0)
    , LLI(0)
    , slip(0)
    , elevation(0.0)
    , azimuth(0.0)
    , err_tropo(0.0)
    , err_iono(_alloc)
    , sat_clk_err(0.0)
    , sat_pos_x(0.0)
    , sat_pos_y(0.0)
    , sat_pos_z(0.0)
    , ttx(0.0)
    , vel_x(0.0)
    , vel_y(0.0)
    , vel_z(0.0)
    , dt(0.0)
    , ddt(0.0)
    , tgd(0.0)
    , visable(0)
    , sat_system(_alloc)
    , visable3DMA(0)
    , prE3dMA(0.0)  {
  (void)_alloc;
    }



   typedef double _GNSS_week_type;
  _GNSS_week_type GNSS_week;

   typedef double _GNSS_time_type;
  _GNSS_time_type GNSS_time;

   typedef double _total_sv_type;
  _total_sv_type total_sv;

   typedef double _prn_satellites_index_type;
  _prn_satellites_index_type prn_satellites_index;

   typedef double _constellation_type;
  _constellation_type constellation;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _pseudorange_type;
  _pseudorange_type pseudorange;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _raw_pseudorange_type;
  _raw_pseudorange_type raw_pseudorange;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _carrier_phase_type;
  _carrier_phase_type carrier_phase;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _raw_carrier_phase_type;
  _raw_carrier_phase_type raw_carrier_phase;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _doppler_type;
  _doppler_type doppler;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _lamda_type;
  _lamda_type lamda;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _snr_type;
  _snr_type snr;

   typedef double _GNCWeights_type;
  _GNCWeights_type GNCWeights;

   typedef int64_t _LLI_type;
  _LLI_type LLI;

   typedef int64_t _slip_type;
  _slip_type slip;

   typedef double _elevation_type;
  _elevation_type elevation;

   typedef double _azimuth_type;
  _azimuth_type azimuth;

   typedef double _err_tropo_type;
  _err_tropo_type err_tropo;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _err_iono_type;
  _err_iono_type err_iono;

   typedef double _sat_clk_err_type;
  _sat_clk_err_type sat_clk_err;

   typedef double _sat_pos_x_type;
  _sat_pos_x_type sat_pos_x;

   typedef double _sat_pos_y_type;
  _sat_pos_y_type sat_pos_y;

   typedef double _sat_pos_z_type;
  _sat_pos_z_type sat_pos_z;

   typedef double _ttx_type;
  _ttx_type ttx;

   typedef double _vel_x_type;
  _vel_x_type vel_x;

   typedef double _vel_y_type;
  _vel_y_type vel_y;

   typedef double _vel_z_type;
  _vel_z_type vel_z;

   typedef double _dt_type;
  _dt_type dt;

   typedef double _ddt_type;
  _ddt_type ddt;

   typedef double _tgd_type;
  _tgd_type tgd;

   typedef int64_t _visable_type;
  _visable_type visable;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _sat_system_type;
  _sat_system_type sat_system;

   typedef int64_t _visable3DMA_type;
  _visable3DMA_type visable3DMA;

   typedef double _prE3dMA_type;
  _prE3dMA_type prE3dMA;





  typedef boost::shared_ptr< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> const> ConstPtr;

}; // struct GNSS_Raw_mf_

typedef ::nlosExclusion::GNSS_Raw_mf_<std::allocator<void> > GNSS_Raw_mf;

typedef boost::shared_ptr< ::nlosExclusion::GNSS_Raw_mf > GNSS_Raw_mfPtr;
typedef boost::shared_ptr< ::nlosExclusion::GNSS_Raw_mf const> GNSS_Raw_mfConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator1> & lhs, const ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator2> & rhs)
{
  return lhs.GNSS_week == rhs.GNSS_week &&
    lhs.GNSS_time == rhs.GNSS_time &&
    lhs.total_sv == rhs.total_sv &&
    lhs.prn_satellites_index == rhs.prn_satellites_index &&
    lhs.constellation == rhs.constellation &&
    lhs.pseudorange == rhs.pseudorange &&
    lhs.raw_pseudorange == rhs.raw_pseudorange &&
    lhs.carrier_phase == rhs.carrier_phase &&
    lhs.raw_carrier_phase == rhs.raw_carrier_phase &&
    lhs.doppler == rhs.doppler &&
    lhs.lamda == rhs.lamda &&
    lhs.snr == rhs.snr &&
    lhs.GNCWeights == rhs.GNCWeights &&
    lhs.LLI == rhs.LLI &&
    lhs.slip == rhs.slip &&
    lhs.elevation == rhs.elevation &&
    lhs.azimuth == rhs.azimuth &&
    lhs.err_tropo == rhs.err_tropo &&
    lhs.err_iono == rhs.err_iono &&
    lhs.sat_clk_err == rhs.sat_clk_err &&
    lhs.sat_pos_x == rhs.sat_pos_x &&
    lhs.sat_pos_y == rhs.sat_pos_y &&
    lhs.sat_pos_z == rhs.sat_pos_z &&
    lhs.ttx == rhs.ttx &&
    lhs.vel_x == rhs.vel_x &&
    lhs.vel_y == rhs.vel_y &&
    lhs.vel_z == rhs.vel_z &&
    lhs.dt == rhs.dt &&
    lhs.ddt == rhs.ddt &&
    lhs.tgd == rhs.tgd &&
    lhs.visable == rhs.visable &&
    lhs.sat_system == rhs.sat_system &&
    lhs.visable3DMA == rhs.visable3DMA &&
    lhs.prE3dMA == rhs.prE3dMA;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator1> & lhs, const ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace nlosExclusion

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> >
{
  static const char* value()
  {
    return "71ffe955c6f4312e94e6527dbb7feca9";
  }

  static const char* value(const ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x71ffe955c6f4312eULL;
  static const uint64_t static_value2 = 0x94e6527dbb7feca9ULL;
};

template<class ContainerAllocator>
struct DataType< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> >
{
  static const char* value()
  {
    return "nlosExclusion/GNSS_Raw_mf";
  }

  static const char* value(const ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 GNSS_week\n"
"float64 GNSS_time\n"
"float64 total_sv\n"
"float64 prn_satellites_index\n"
"float64 constellation\n"
"float64[] pseudorange\n"
"float64[] raw_pseudorange\n"
"float64[] carrier_phase\n"
"float64[] raw_carrier_phase\n"
"float64[] doppler\n"
"float64[] lamda\n"
"float64[] snr\n"
"float64 GNCWeights\n"
"int64 LLI\n"
"int64 slip #0 no cycle slip or no carrier, 1 yes\n"
"float64 elevation\n"
"float64 azimuth\n"
"float64 err_tropo\n"
"float64[] err_iono\n"
"float64 sat_clk_err\n"
"float64 sat_pos_x\n"
"float64 sat_pos_y\n"
"float64 sat_pos_z\n"
"float64 ttx # satellite obstime - tof - satellite clock bias\n"
"float64 vel_x # satellite velocity \n"
"float64 vel_y # satellite velocity \n"
"float64 vel_z # satellite velocity \n"
"float64 dt # satellite clock drift\n"
"float64 ddt # satellite clock drift rate\n"
"float64 tgd # /* group delay parameters (Prange function in RTKLIB) */\n"
"#float64 GNSSCovariance\n"
"int64 visable #0-Not sure 1-visable 2-invisable\n"
"string  sat_system\n"
"int64 visable3DMA # ground truth visibility from 3DMA\n"
"float64 prE3dMA # ground truth pseudorange error from 3DMA\n"
"\n"
;
  }

  static const char* value(const ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.GNSS_week);
      stream.next(m.GNSS_time);
      stream.next(m.total_sv);
      stream.next(m.prn_satellites_index);
      stream.next(m.constellation);
      stream.next(m.pseudorange);
      stream.next(m.raw_pseudorange);
      stream.next(m.carrier_phase);
      stream.next(m.raw_carrier_phase);
      stream.next(m.doppler);
      stream.next(m.lamda);
      stream.next(m.snr);
      stream.next(m.GNCWeights);
      stream.next(m.LLI);
      stream.next(m.slip);
      stream.next(m.elevation);
      stream.next(m.azimuth);
      stream.next(m.err_tropo);
      stream.next(m.err_iono);
      stream.next(m.sat_clk_err);
      stream.next(m.sat_pos_x);
      stream.next(m.sat_pos_y);
      stream.next(m.sat_pos_z);
      stream.next(m.ttx);
      stream.next(m.vel_x);
      stream.next(m.vel_y);
      stream.next(m.vel_z);
      stream.next(m.dt);
      stream.next(m.ddt);
      stream.next(m.tgd);
      stream.next(m.visable);
      stream.next(m.sat_system);
      stream.next(m.visable3DMA);
      stream.next(m.prE3dMA);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct GNSS_Raw_mf_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::nlosExclusion::GNSS_Raw_mf_<ContainerAllocator>& v)
  {
    s << indent << "GNSS_week: ";
    Printer<double>::stream(s, indent + "  ", v.GNSS_week);
    s << indent << "GNSS_time: ";
    Printer<double>::stream(s, indent + "  ", v.GNSS_time);
    s << indent << "total_sv: ";
    Printer<double>::stream(s, indent + "  ", v.total_sv);
    s << indent << "prn_satellites_index: ";
    Printer<double>::stream(s, indent + "  ", v.prn_satellites_index);
    s << indent << "constellation: ";
    Printer<double>::stream(s, indent + "  ", v.constellation);
    s << indent << "pseudorange[]" << std::endl;
    for (size_t i = 0; i < v.pseudorange.size(); ++i)
    {
      s << indent << "  pseudorange[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.pseudorange[i]);
    }
    s << indent << "raw_pseudorange[]" << std::endl;
    for (size_t i = 0; i < v.raw_pseudorange.size(); ++i)
    {
      s << indent << "  raw_pseudorange[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.raw_pseudorange[i]);
    }
    s << indent << "carrier_phase[]" << std::endl;
    for (size_t i = 0; i < v.carrier_phase.size(); ++i)
    {
      s << indent << "  carrier_phase[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.carrier_phase[i]);
    }
    s << indent << "raw_carrier_phase[]" << std::endl;
    for (size_t i = 0; i < v.raw_carrier_phase.size(); ++i)
    {
      s << indent << "  raw_carrier_phase[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.raw_carrier_phase[i]);
    }
    s << indent << "doppler[]" << std::endl;
    for (size_t i = 0; i < v.doppler.size(); ++i)
    {
      s << indent << "  doppler[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.doppler[i]);
    }
    s << indent << "lamda[]" << std::endl;
    for (size_t i = 0; i < v.lamda.size(); ++i)
    {
      s << indent << "  lamda[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.lamda[i]);
    }
    s << indent << "snr[]" << std::endl;
    for (size_t i = 0; i < v.snr.size(); ++i)
    {
      s << indent << "  snr[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.snr[i]);
    }
    s << indent << "GNCWeights: ";
    Printer<double>::stream(s, indent + "  ", v.GNCWeights);
    s << indent << "LLI: ";
    Printer<int64_t>::stream(s, indent + "  ", v.LLI);
    s << indent << "slip: ";
    Printer<int64_t>::stream(s, indent + "  ", v.slip);
    s << indent << "elevation: ";
    Printer<double>::stream(s, indent + "  ", v.elevation);
    s << indent << "azimuth: ";
    Printer<double>::stream(s, indent + "  ", v.azimuth);
    s << indent << "err_tropo: ";
    Printer<double>::stream(s, indent + "  ", v.err_tropo);
    s << indent << "err_iono[]" << std::endl;
    for (size_t i = 0; i < v.err_iono.size(); ++i)
    {
      s << indent << "  err_iono[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.err_iono[i]);
    }
    s << indent << "sat_clk_err: ";
    Printer<double>::stream(s, indent + "  ", v.sat_clk_err);
    s << indent << "sat_pos_x: ";
    Printer<double>::stream(s, indent + "  ", v.sat_pos_x);
    s << indent << "sat_pos_y: ";
    Printer<double>::stream(s, indent + "  ", v.sat_pos_y);
    s << indent << "sat_pos_z: ";
    Printer<double>::stream(s, indent + "  ", v.sat_pos_z);
    s << indent << "ttx: ";
    Printer<double>::stream(s, indent + "  ", v.ttx);
    s << indent << "vel_x: ";
    Printer<double>::stream(s, indent + "  ", v.vel_x);
    s << indent << "vel_y: ";
    Printer<double>::stream(s, indent + "  ", v.vel_y);
    s << indent << "vel_z: ";
    Printer<double>::stream(s, indent + "  ", v.vel_z);
    s << indent << "dt: ";
    Printer<double>::stream(s, indent + "  ", v.dt);
    s << indent << "ddt: ";
    Printer<double>::stream(s, indent + "  ", v.ddt);
    s << indent << "tgd: ";
    Printer<double>::stream(s, indent + "  ", v.tgd);
    s << indent << "visable: ";
    Printer<int64_t>::stream(s, indent + "  ", v.visable);
    s << indent << "sat_system: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.sat_system);
    s << indent << "visable3DMA: ";
    Printer<int64_t>::stream(s, indent + "  ", v.visable3DMA);
    s << indent << "prE3dMA: ";
    Printer<double>::stream(s, indent + "  ", v.prE3dMA);
  }
};

} // namespace message_operations
} // namespace ros

#endif // NLOSEXCLUSION_MESSAGE_GNSS_RAW_MF_H
